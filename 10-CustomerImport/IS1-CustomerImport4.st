Object subclass: #Address	instanceVariableNames: 'id streetName streetNumber town zipCode province'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 13:27'!streetNumber: aStreetNumber 	streetNumber := aStreetNumber ! !!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 13:27'!streetName: aStreetName 	streetName := aStreetName ! !!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 16:12'!streetName	^streetName ! !!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 16:12'!streetNumber	^streetNumber ! !!Address methodsFor: 'twon' stamp: 'HernanWilkinson 10/28/2016 16:07'!town: aTown 	town := aTown! !!Address methodsFor: 'twon' stamp: 'HernanWilkinson 10/28/2016 16:12'!town	^town! !!Address methodsFor: 'province' stamp: 'HernanWilkinson 10/28/2016 16:11'!province	^province! !!Address methodsFor: 'province' stamp: 'HernanWilkinson 10/28/2016 16:08'!province: aProvince 	province := aProvince	! !!Address methodsFor: 'zip code' stamp: 'HernanWilkinson 10/28/2016 16:08'!zipCode: aZipCode 	zipCode := aZipCode! !!Address methodsFor: 'zip code' stamp: 'HernanWilkinson 10/28/2016 16:13'!zipCode	^zipCode! !!Address methodsFor: 'testing' stamp: 'HernanWilkinson 11/1/2016 10:06'!isAt: aStreetName	^streetName = aStreetName ! !Object subclass: #CSVImporter	instanceVariableNames: 'line readStream record newCustomer system newSupplier recordParsers'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!CSVImporter methodsFor: 'importing' stamp: 'LREV 7/1/2018 20:46'!import	self subclassResponsibility ! !!CSVImporter methodsFor: 'asserting' stamp: 'LREV 7/1/2018 20:45'!assertRecordNotEmpty	self subclassResponsibility ! !!CSVImporter methodsFor: 'initialization' stamp: 'LREV 7/1/2018 21:45'!initializeOn: aReadStream using: aCustomerSystem	self subclassResponsibility ! !!CSVImporter methodsFor: 'importing - private' stamp: 'LREV 6/28/2018 21:06'!importRecord
	self subclassResponsibility! !!CSVImporter methodsFor: 'importing - private' stamp: 'LREV 7/1/2018 20:46'!canImportNextLine	self subclassResponsibility ! !!CSVImporter methodsFor: 'importing - private' stamp: 'LREV 7/1/2018 20:47'!convertLineToRecord	self subclassResponsibility ! !!CSVImporter methodsFor: 'error signal' stamp: 'LREV 7/1/2018 20:46'!signalInvalidRecordType	self subclassResponsibility ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CSVImporter class	instanceVariableNames: ''!!CSVImporter class methodsFor: 'instance creation' stamp: 'LREV 7/1/2018 21:44'!from: aReadStream using: aCustomerSystem	self subclassResponsibility ! !!CSVImporter class methodsFor: 'error descriptions' stamp: 'LREV 7/1/2018 20:49'!invalidAddressRecordErrorDescription	self subclassResponsibility ! !!CSVImporter class methodsFor: 'error descriptions' stamp: 'LREV 6/28/2018 21:06'!addressWithoutCustomerErrorDescription
	self subclassResponsibility! !!CSVImporter class methodsFor: 'error descriptions' stamp: 'LREV 7/1/2018 20:49'!invalidRecordTypeErrorDescription		self subclassResponsibility ! !!CSVImporter class methodsFor: 'error descriptions' stamp: 'LREV 7/1/2018 20:49'!invalidCustomerRecordErrorDescription		self subclassResponsibility ! !TestCase subclass: #CustomerImportTest	instanceVariableNames: 'importer system recordParsers'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!CustomerImportTest methodsFor: 'test data - address' stamp: 'HernanWilkinson 11/2/2016 10:45'!addressRecordWithMoreThanSixFieldsTestData		^ ReadStream on: self alwaysImportedCustomerRecord,'A,San Martin,3322,Olivos,1636,BsAs,y otra cosa'! !!CustomerImportTest methodsFor: 'test data - address' stamp: 'HernanWilkinson 11/1/2016 15:59'!addressWithoutCustomerTestData		^ ReadStream on: 'A,San Martin,3322,Olivos,1636,BsAs'! !!CustomerImportTest methodsFor: 'test data - address' stamp: 'HernanWilkinson 11/2/2016 10:45'!addressRecordWithLessThanSixFieldsTestData		^ ReadStream on: self alwaysImportedCustomerRecord,'A,San Martin,3322,Olivos,1636'! !!CustomerImportTest methodsFor: 'test data - address' stamp: 'HernanWilkinson 11/2/2016 10:45'!addressRecordStartingWithMoreThanOneATestData		^ ReadStream on: self alwaysImportedCustomerRecord,'AA,San Martin,3322,Olivos,1636,BsAs'! !!CustomerImportTest methodsFor: 'setup-teardown' stamp: 'LREV 6/30/2018 14:05'!setUp	system := Environment current createCustomerSystem.	system start.	system beginTransaction.	recordParsers := Array		with: (AddressRecordParser for: 'A')		with: (CustomerRecordParser for: 'C')! !!CustomerImportTest methodsFor: 'setup-teardown' stamp: 'HernanWilkinson 11/4/2016 09:52'!tearDown	system commit.	system shutdown! !!CustomerImportTest methodsFor: 'importing' stamp: 'LREV 7/1/2018 21:44'!importCustomersFrom: inputStream	(CustomerImporter from: inputStream using: system) import! !!CustomerImportTest methodsFor: 'test data' stamp: 'HernanWilkinson 11/2/2016 10:46'!validTestData	^ ReadStream on: self alwaysImportedCustomerRecord,'A,San Martin,3322,Olivos,1636,BsAsA,Maipu,888,Florida,1122,Buenos AiresC,Juan,Perez,C,23-25666777-9A,Alem,1122,CABA,1001,CABA'! !!CustomerImportTest methodsFor: 'test data' stamp: 'HernanWilkinson 11/2/2016 15:52'!dataWithEmptyLine		^ ReadStream on: self alwaysImportedCustomerRecord,'A,San Martin,3322,Olivos,1636,BsAs'! !!CustomerImportTest methodsFor: 'testing' stamp: 'HernanWilkinson 11/3/2016 09:11'!testCanNotImportCustomerRecordWithMoreThanFiveFields	self		should: [ self				importCustomersFrom: self customerRecordWithMoreThanFiveFieldsTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: CustomerImporter invalidCustomerRecordErrorDescription.			self assert: system customersIsEmpty ]! !!CustomerImportTest methodsFor: 'testing' stamp: 'HernanWilkinson 11/2/2016 15:52'!testEmptyLinesAreRecognizedAsInvalidRecords		self		should: [ self importCustomersFrom: self dataWithEmptyLine ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self assert: anError messageText equals: CustomerImporter invalidRecordTypeErrorDescription.			self assert: self alwaysImportedCustomer addressesIsEmpty ]! !!CustomerImportTest methodsFor: 'testing' stamp: 'HernanWilkinson 11/3/2016 09:11'!testCanNotImportAddressWithoutCustomer	self		should: [ self importCustomersFrom: self addressWithoutCustomerTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: CustomerImporter addressWithoutCustomerErrorDescription.			self assert: system customersIsEmpty ]! !!CustomerImportTest methodsFor: 'testing' stamp: 'HernanWilkinson 11/1/2016 15:56'!testImportCustomers	self importCustomersFrom: self validTestData.	self assertImportedCustomersSizeIsCorrect.	self assertPepeSanchezWasImportedCorrectly.	self assertJuanPerezWasImportedCorrectly! !!CustomerImportTest methodsFor: 'testing' stamp: 'HernanWilkinson 11/2/2016 10:42'!testShouldNotImportAddressRecordsStartingWithMoreThanA	self 		should: [ self importCustomersFrom: self addressRecordStartingWithMoreThanOneATestData ]		raise: Error - MessageNotUnderstood 		withExceptionDo: [ :anError | 			self assert: anError messageText equals: CustomerImporter invalidRecordTypeErrorDescription.			self assert: self alwaysImportedCustomer addressesIsEmpty ]	! !!CustomerImportTest methodsFor: 'testing' stamp: 'HernanWilkinson 11/3/2016 09:11'!testCanNotImportCustomerRecordWithLessThanFiveFields	self		should: [ self				importCustomersFrom: self customerRecordWithLessThanFiveFieldsTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: CustomerImporter invalidCustomerRecordErrorDescription.			self assert: system customersIsEmpty ]! !!CustomerImportTest methodsFor: 'testing' stamp: 'HernanWilkinson 11/2/2016 10:41'!testCanNotImportAddressRecordWithLessThanSixFields		self		should: [ self importCustomersFrom: self addressRecordWithLessThanSixFieldsTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self assert: anError messageText equals: CustomerImporter invalidAddressRecordErrorDescription.			self assert: self alwaysImportedCustomer addressesIsEmpty ]! !!CustomerImportTest methodsFor: 'testing' stamp: 'HernanWilkinson 11/2/2016 10:42'!testCanNotImportAddressRecordWithMoreThanSixFields	self 		should: [ self importCustomersFrom: self addressRecordWithMoreThanSixFieldsTestData ]		raise: Error - MessageNotUnderstood 		withExceptionDo: [ :anError | 			self assert: anError messageText equals: CustomerImporter invalidAddressRecordErrorDescription.			self assert: self alwaysImportedCustomer addressesIsEmpty ]	! !!CustomerImportTest methodsFor: 'testing' stamp: 'HernanWilkinson 11/3/2016 09:11'!testShouldNotImportCustomerRecordsStartingWithMoreThanC	self		should: [ self				importCustomersFrom: self customerRecordStartingWithMoreThanOneCTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: CustomerImporter invalidRecordTypeErrorDescription.			self assert: system customersIsEmpty ]! !!CustomerImportTest methodsFor: 'test data - customer' stamp: 'LREV 6/30/2018 16:12'!alwaysImportedCustomer	| anIdentificationNumber anIdentifycationType |	anIdentifycationType := self alwaysImportedCustomerIdType.	anIdentificationNumber := self alwaysImportedCustomerIdNumber.	^ system		customerIdentifiedAs: anIdentifycationType		numbered: anIdentificationNumber		ifNone: [ self error: 'Customer not Imported' ]! !!CustomerImportTest methodsFor: 'test data - customer' stamp: 'HernanWilkinson 11/2/2016 10:46'!alwaysImportedCustomerIdType	^ 'D'! !!CustomerImportTest methodsFor: 'test data - customer' stamp: 'HernanWilkinson 11/2/2016 10:47'!alwaysImportedCustomerIdNumber	^ '22333444'! !!CustomerImportTest methodsFor: 'test data - customer' stamp: 'HernanWilkinson 11/2/2016 10:53'!customerRecordWithMoreThanFiveFieldsTestData		^ ReadStream on: self alwaysImportedCustomerRecord,',x'! !!CustomerImportTest methodsFor: 'test data - customer' stamp: 'HernanWilkinson 11/2/2016 10:47'!alwaysImportedCustomerRecord	^ 'C,Pepe,Sanchez,', self alwaysImportedCustomerIdType, ',', self alwaysImportedCustomerIdNumber ! !!CustomerImportTest methodsFor: 'test data - customer' stamp: 'HernanWilkinson 11/1/2016 17:48'!customerRecordStartingWithMoreThanOneCTestData		^ ReadStream on:'CC,Pepe,Sanchez,D,22333444'! !!CustomerImportTest methodsFor: 'test data - customer' stamp: 'HernanWilkinson 11/2/2016 10:50'!customerRecordWithLessThanFiveFieldsTestData		^ ReadStream on: 'C,Pepe,Sanchez,D'! !!CustomerImportTest methodsFor: 'asserting' stamp: 'HernanWilkinson 11/3/2016 09:20'!assertPepeSanchezWasImportedCorrectly	| customer |	customer := self alwaysImportedCustomer. 		self assert: customer isNamed: 'Pepe' lastName: 'Sanchez' identfiedAs: self alwaysImportedCustomerIdType withNumber: self alwaysImportedCustomerIdNumber andNumberOfAddresses: 2.	self assert: customer hasAddressAt: 'San Martin' number: 3322 in: 'Olivos' zipCode: 1636 province: 'BsAs'.	self assert: customer hasAddressAt: 'Maipu' number: 888 in: 'Florida' zipCode: 1122 province: 'Buenos Aires'! !!CustomerImportTest methodsFor: 'asserting' stamp: 'HernanWilkinson 11/1/2016 11:00'!assert: customer hasAddressAt: streetName number: streetNumber in: town zipCode: zipCode province: province	| address |		address := customer addressAt: streetName ifNone: [ self fail ].	self assert: address streetName equals: streetName.	self assert: address streetNumber equals: streetNumber.	self assert: address town equals: town.	self assert: address zipCode equals: zipCode.	self assert: address province equals: province.	! !!CustomerImportTest methodsFor: 'asserting' stamp: 'LREV 6/30/2018 16:13'!assertJuanPerezWasImportedCorrectly	| customer idType idNumber |	idType := 'C'.	idNumber := '23-25666777-9'.	customer := system		customerIdentifiedAs: idType		numbered: idNumber		ifNone: [ self error: 'Customer not Imported' ].	self		assert: customer		isNamed: 'Juan'		lastName: 'Perez'		identfiedAs: idType		withNumber: idNumber		andNumberOfAddresses: 1.	self		assert: customer		hasAddressAt: 'Alem'		number: 1122		in: 'CABA'		zipCode: 1001		province: 'CABA'! !!CustomerImportTest methodsFor: 'asserting' stamp: 'HernanWilkinson 11/3/2016 09:10'!assertImportedCustomersSizeIsCorrect	self assert: system allCustomers size equals: 2! !!CustomerImportTest methodsFor: 'asserting' stamp: 'HernanWilkinson 11/1/2016 10:56'!assert: customer isNamed: firstName lastName: lastName identfiedAs: idType withNumber: idNumber andNumberOfAddresses: addressesSize	self assert: customer firstName equals: firstName.	self assert: customer lastName equals: lastName.	self assert: customer identificationType equals: idType.	self assert: customer identificationNumber equals: idNumber.	self assert: customer numberOfAddresses equals: addressesSize .! !CSVImporter subclass: #CustomerImporter	instanceVariableNames: 'lastAdded'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!CustomerImporter methodsFor: 'initialization' stamp: 'LREV 7/1/2018 21:45'!initializeOn: aReadStream using: aCustomerSystem	readStream := aReadStream.	system := aCustomerSystem.	recordParsers := 	Array		with: (AddressRecordParser for: 'A')		with: (CustomerRecordParser for: 'C').! !!CustomerImporter methodsFor: 'importing - private' stamp: 'LREV 6/30/2018 14:44'!importRecord	|parser|	parser := recordParsers		detect: [ :aRecordParser | aRecordParser isFor: record first ] ifNone: [self signalInvalidRecordType].			parser parse: record for: self.		! !!CustomerImporter methodsFor: 'importing - private' stamp: 'LREV 6/29/2018 20:36'!assertRecordNotEmpty		record isEmpty ifTrue: [ self signalInvalidRecordType ]! !!CustomerImporter methodsFor: 'importing - private' stamp: 'LREV 7/1/2018 20:46'!canImportNextLine	line := readStream nextLine.	^ line notNil! !!CustomerImporter methodsFor: 'importing - private' stamp: 'LREV 7/1/2018 20:47'!convertLineToRecord	record := line substrings: {$,}.		self assertRecordNotEmpty! !!CustomerImporter methodsFor: 'importing - private - customer' stamp: 'LREV 6/30/2018 14:46'!importCustomer: aCustomer.	newCustomer:= aCustomer.	system add: newCustomer.	! !!CustomerImporter methodsFor: 'importing - private - address' stamp: 'LREV 6/30/2018 14:46'!importAddress: anAddress	self assertThereIsCustsomerForAddress.	newCustomer addAddress: anAddress! !!CustomerImporter methodsFor: 'importing - private - address' stamp: 'HernanWilkinson 11/2/2016 10:56'!assertThereIsCustsomerForAddress	newCustomer isNil ifTrue: [ self signalAddressWithoutCustomerError ].	! !!CustomerImporter methodsFor: 'importing' stamp: 'LREV 7/1/2018 20:46'!import	[ self canImportNextLine ] whileTrue: [ 		self convertLineToRecord.		self importRecord ]! !!CustomerImporter methodsFor: 'error signal' stamp: 'HernanWilkinson 11/1/2016 16:01'!signalAddressWithoutCustomerError	self error: self class addressWithoutCustomerErrorDescription.! !!CustomerImporter methodsFor: 'error signal' stamp: 'LREV 7/1/2018 20:46'!signalInvalidRecordType	self error: self class invalidRecordTypeErrorDescription! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CustomerImporter class	instanceVariableNames: ''!!CustomerImporter class methodsFor: 'error descriptions' stamp: 'LREV 6/29/2018 20:40'!invalidCustomerRecordErrorDescription		^'Invalid customer record'! !!CustomerImporter class methodsFor: 'error descriptions' stamp: 'HernanWilkinson 11/1/2016 16:02'!addressWithoutCustomerErrorDescription		^'There is no Customer for the imported address'! !!CustomerImporter class methodsFor: 'error descriptions' stamp: 'LREV 6/29/2018 20:40'!invalidRecordTypeErrorDescription		^'Invalid record type'! !!CustomerImporter class methodsFor: 'error descriptions' stamp: 'LREV 6/29/2018 20:40'!invalidAddressRecordErrorDescription		^'Invalid address record'! !!CustomerImporter class methodsFor: 'instance creation' stamp: 'LREV 7/1/2018 21:45'!from: aReadStream using: aCustomerSystem	^ self new initializeOn: aReadStream using: aCustomerSystem! !Object subclass: #ERPSystem	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!ERPSystem methodsFor: 'customers' stamp: 'HernanWilkinson 11/4/2016 09:35'!allCustomers	self subclassResponsibility! !!ERPSystem methodsFor: 'customers' stamp: 'HernanWilkinson 11/4/2016 09:35'!customersIsEmpty	self subclassResponsibility! !!ERPSystem methodsFor: 'customers' stamp: 'LREV 6/29/2018 21:53'!customerIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber ifNone: anObject	self subclassResponsibility! !!ERPSystem methodsFor: 'customers' stamp: 'HernanWilkinson 11/4/2016 09:35'!add: aCustomer	self subclassResponsibility! !!ERPSystem methodsFor: 'transaction' stamp: 'HernanWilkinson 11/4/2016 09:35'!beginTransaction	self subclassResponsibility! !!ERPSystem methodsFor: 'transaction' stamp: 'HernanWilkinson 11/4/2016 09:35'!commit	self subclassResponsibility! !!ERPSystem methodsFor: 'system live cycle' stamp: 'HernanWilkinson 11/4/2016 09:52'!shutdown	self subclassResponsibility! !!ERPSystem methodsFor: 'system live cycle' stamp: 'HernanWilkinson 11/4/2016 09:51'!start	self subclassResponsibility! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ERPSystem class	instanceVariableNames: ''!!ERPSystem class methodsFor: 'as yet unclassified' stamp: 'LREV 6/28/2018 19:58'!supplierNotInSystemErrorMsg	self subclassResponsibility ! !Object subclass: #Environment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!Environment methodsFor: 'system creation' stamp: 'HernanWilkinson 11/4/2016 09:49'!createCustomerSystem	self subclassResponsibility ! !!Environment methodsFor: 'system creation' stamp: 'LREV 7/1/2018 20:31'!createSupplierSystem	self subclassResponsibility ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Environment class	instanceVariableNames: ''!!Environment class methodsFor: 'enviroment selection' stamp: 'HernanWilkinson 11/4/2016 09:46'!current		^self allSubclasses 		detect: [ :anEnvironemntClass | anEnvironemntClass isCurrent ]		ifFound: [ :anEnvironmentClass | anEnvironmentClass new ]		ifNone: [ self error: 'No environment detected' ]! !!Environment class methodsFor: 'enviroment selection' stamp: 'HernanWilkinson 11/4/2016 09:49'!isCurrent	self subclassResponsibility ! !Environment subclass: #DevelpmentEnvironment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!DevelpmentEnvironment methodsFor: 'system creation' stamp: 'HernanWilkinson 11/4/2016 09:47'!createCustomerSystem		^TransientCustomerSystem new! !!DevelpmentEnvironment methodsFor: 'system creation' stamp: 'LREV 6/30/2018 23:18'!createSupplierSystem		^TransientSupplierSystem new! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DevelpmentEnvironment class	instanceVariableNames: ''!!DevelpmentEnvironment class methodsFor: 'as yet unclassified' stamp: 'HernanWilkinson 11/4/2016 09:47'!isCurrent		^IntegrationEnvironment isCurrent not! !Environment subclass: #IntegrationEnvironment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!IntegrationEnvironment methodsFor: 'system creation' stamp: 'HernanWilkinson 11/4/2016 09:45'!createCustomerSystem		^PersistentCustomerSystem new! !!IntegrationEnvironment methodsFor: 'system creation' stamp: 'LREV 6/30/2018 23:17'!createSupplierSystem		^PersistentSupplierSystem new! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!IntegrationEnvironment class	instanceVariableNames: ''!!IntegrationEnvironment class methodsFor: 'as yet unclassified' stamp: 'HernanWilkinson 11/4/2016 09:47'!not	self shouldBeImplemented.! !!IntegrationEnvironment class methodsFor: 'testing' stamp: 'LREV 7/2/2018 09:10'!isCurrent		^true! !Object subclass: #Party	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!Party methodsFor: 'identification' stamp: 'LREV 6/28/2018 19:36'!identificationNumber: anIdentificationNumber
	self subclassResponsibility! !!Party methodsFor: 'identification' stamp: 'LREV 6/28/2018 19:36'!isIdentifiedAs: anIdType numbered: anIdNumber
	self subclassResponsibility! !!Party methodsFor: 'identification' stamp: 'LREV 6/28/2018 19:36'!identificationType
	self subclassResponsibility! !!Party methodsFor: 'identification' stamp: 'LREV 6/28/2018 19:36'!identificationType: anIdentificationType
	self subclassResponsibility! !!Party methodsFor: 'identification' stamp: 'LREV 6/28/2018 19:36'!identificationNumber
	self subclassResponsibility! !!Party methodsFor: 'addresses' stamp: 'LREV 6/28/2018 19:36'!numberOfAddresses
	self subclassResponsibility! !!Party methodsFor: 'addresses' stamp: 'LREV 6/28/2018 19:36'!addressesIsEmpty
	self subclassResponsibility! !Party subclass: #Customer	instanceVariableNames: 'lastName id firstName identificationType identificationNumber addresses'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!Customer methodsFor: 'initialization' stamp: 'LREV 7/1/2018 14:50'!initialize	super initialize.	addresses := OrderedCollection new.! !!Customer methodsFor: 'addresses' stamp: 'LREV 6/29/2018 19:58'!addresses	^ addresses copy.! !!Customer methodsFor: 'addresses' stamp: 'LREV 6/29/2018 19:59'!addAddress: anAddress 	addresses add: anAddress ! !!Customer methodsFor: 'addresses' stamp: 'HernanWilkinson 11/1/2016 09:43'!numberOfAddresses		^addresses size! !!Customer methodsFor: 'addresses' stamp: 'LREV 6/29/2018 19:59'!addressAt: aStreetName ifNone: noneClosure 		^addresses detect: [ :anAddress | anAddress isAt: aStreetName ] ifNone: noneClosure ! !!Customer methodsFor: 'addresses' stamp: 'HernanWilkinson 11/1/2016 18:03'!addressesIsEmpty		^addresses isEmpty! !!Customer methodsFor: 'identification' stamp: 'HernanWilkinson 10/28/2016 13:10'!identificationNumber: anIdentificationNumber 	identificationNumber := anIdentificationNumber! !!Customer methodsFor: 'identification' stamp: 'HernanWilkinson 11/4/2016 09:42'!isIdentifiedAs: anIdType numbered: anIdNumber 		^identificationType = anIdType and: [ identificationNumber = anIdNumber  ]! !!Customer methodsFor: 'identification' stamp: 'HernanWilkinson 10/28/2016 16:13'!identificationType		^identificationType ! !!Customer methodsFor: 'identification' stamp: 'HernanWilkinson 10/28/2016 13:10'!identificationType: anIdentificationType 	identificationType := anIdentificationType! !!Customer methodsFor: 'identification' stamp: 'HernanWilkinson 10/28/2016 16:13'!identificationNumber		^identificationNumber ! !!Customer methodsFor: 'as yet unclassified' stamp: 'LREV 7/1/2018 14:51'!initializedAsNamed: aName lastName: aLastName identifiedAs: anIDType numbered: anIDNumber 	self firstName: aName.	self lastName: aLastName.	self identificationNumber: anIDNumber.	self identificationType: anIDType.	addresses := OrderedCollection new.! !!Customer methodsFor: 'name' stamp: 'LREV 6/28/2018 19:40'!lastName: aName 	lastName := aName! !!Customer methodsFor: 'name' stamp: 'HernanWilkinson 10/28/2016 13:09'!firstName: aName 	firstName := aName! !!Customer methodsFor: 'name' stamp: 'HernanWilkinson 10/28/2016 16:15'!firstName		^firstName ! !!Customer methodsFor: 'name' stamp: 'LREV 6/28/2018 19:40'!lastName		^lastName ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Customer class	instanceVariableNames: ''!!Customer class methodsFor: 'as yet unclassified' stamp: 'LREV 6/28/2018 20:37'!named: aName lastName: aLastName identifiedAs: anIDType numbered: anIDNumber 	^ self new initializedAsNamed: aName lastName: aLastName identifiedAs: anIDType numbered: anIDNumber ! !ERPSystem subclass: #PersistentCustomerSystem	instanceVariableNames: 'session'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!PersistentCustomerSystem methodsFor: 'mapping' stamp: 'HernanWilkinson 11/3/2016 08:52'!addressMapping	^ ClassMapping		withDefaultTableNameFor: Address		mappingAll:			(Array				with: (EmbededMapping withDefaultFieldNameFor: #streetName)				with: (EmbededMapping withDefaultFieldNameFor: #streetNumber)				with: (EmbededMapping withDefaultFieldNameFor: #town)				with: (EmbededMapping withDefaultFieldNameFor: #zipCode)				with: (EmbededMapping withDefaultFieldNameFor: #province))! !!PersistentCustomerSystem methodsFor: 'mapping' stamp: 'HernanWilkinson 11/3/2016 08:52'!customerMapping	^ ClassMapping		withDefaultTableNameFor: Customer		mappingAll:			(Array				with: (EmbededMapping withDefaultFieldNameFor: #firstName)				with: (EmbededMapping withDefaultFieldNameFor: #lastName)				with: (EmbededMapping withDefaultFieldNameFor: #identificationType)				with: (EmbededMapping withDefaultFieldNameFor: #identificationNumber)				with: (OneToManyMapping withDefaultFieldNameFor: #addresses ofType: Address))! !!PersistentCustomerSystem methodsFor: 'system live cycle' stamp: 'HernanWilkinson 11/4/2016 09:52'!shutdown	session shutdown! !!PersistentCustomerSystem methodsFor: 'system live cycle' stamp: 'HernanWilkinson 11/4/2016 09:51'!start	session start! !!PersistentCustomerSystem methodsFor: 'accessing - private' stamp: 'LREV 7/1/2018 00:01'!getSession	^session copy! !!PersistentCustomerSystem methodsFor: 'transaction' stamp: 'HernanWilkinson 11/4/2016 09:18'!beginTransaction	session beginTransaction! !!PersistentCustomerSystem methodsFor: 'transaction' stamp: 'HernanWilkinson 11/4/2016 09:18'!commit	session commit! !!PersistentCustomerSystem methodsFor: 'customers' stamp: 'HernanWilkinson 11/4/2016 09:18'!allCustomers	^ session selectAllOfType: Customer! !!PersistentCustomerSystem methodsFor: 'customers' stamp: 'HernanWilkinson 11/3/2016 09:11'!customersIsEmpty	^ self allCustomers isEmpty! !!PersistentCustomerSystem methodsFor: 'customers' stamp: 'LREV 7/1/2018 21:14'!customerIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber ifNone: aBlockForAbsense	| customers |	customers := session		select: [ :aCustomer | 			aCustomer identificationType = anIdentifycationType				and: [ aCustomer identificationNumber = anIdentificationNumber ] ]		ofType: Customer.	customers size = 1		ifFalse: [ aBlockForAbsense value ].	^ customers anyOne! !!PersistentCustomerSystem methodsFor: 'customers' stamp: 'LREV 6/30/2018 20:26'!add: aParty	session persist: aParty! !!PersistentCustomerSystem methodsFor: 'initialization' stamp: 'HernanWilkinson 11/3/2016 08:54'!initialize		super initialize.	self initializeSession. ! !!PersistentCustomerSystem methodsFor: 'initialization' stamp: 'LREV 7/1/2018 00:07'!initializeSession	session := DataBaseSession		for: (Array with: self addressMapping with: self customerMapping )! !!PersistentCustomerSystem methodsFor: 'initialization' stamp: 'LREV 6/30/2018 23:49'!initializeFor: aMapping	session := DataBaseSession		for: (Array with: self addressMapping with: self customerMapping with: aMapping )! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PersistentCustomerSystem class	instanceVariableNames: ''!!PersistentCustomerSystem class methodsFor: 'instance creation' stamp: 'LREV 6/30/2018 23:48'!for: aMapping	^self new initializeFor: aMapping.! !ERPSystem subclass: #PersistentSupplierSystem	instanceVariableNames: 'session customerSystem'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!PersistentSupplierSystem methodsFor: 'initialization' stamp: 'LREV 6/30/2018 23:51'!initialize		super initialize.	customerSystem := PersistentCustomerSystem for: self supplierMapping.! !!PersistentSupplierSystem methodsFor: 'customers' stamp: 'LREV 6/30/2018 23:52'!allCustomers	^ customerSystem allCustomers ! !!PersistentSupplierSystem methodsFor: 'customers' stamp: 'LREV 7/1/2018 00:02'!customersIsEmpty	^ customerSystem customersIsEmpty ! !!PersistentSupplierSystem methodsFor: 'customers' stamp: 'LREV 7/1/2018 00:02'!customerIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber ifNone: aBlockForAbsence	^customerSystem customerIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber ifNone: aBlockForAbsence! !!PersistentSupplierSystem methodsFor: 'customers' stamp: 'LREV 6/30/2018 23:52'!add: aParty	customerSystem add: aParty! !!PersistentSupplierSystem methodsFor: 'system live cycle' stamp: 'LREV 7/1/2018 00:06'!shutdown	customerSystem  shutdown! !!PersistentSupplierSystem methodsFor: 'system live cycle' stamp: 'LREV 7/1/2018 00:02'!start	customerSystem  start! !!PersistentSupplierSystem methodsFor: 'suppliers' stamp: 'LREV 7/1/2018 00:03'!supplierIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber	| suppliers |	session := customerSystem getSession .	suppliers  := session		select: [ :aSupplier | 			aSupplier  identificationType = anIdentifycationType				and: [ aSupplier  identificationNumber = anIdentificationNumber ] ]		ofType: Supplier .	suppliers  size = 1		ifFalse: [ self error: 'No o more that one customer found' ].	^ suppliers  anyOne! !!PersistentSupplierSystem methodsFor: 'suppliers' stamp: 'LREV 7/1/2018 00:01'!allSuppliers	^ (customerSystem getSession)  selectAllOfType: Supplier! !!PersistentSupplierSystem methodsFor: 'suppliers' stamp: 'LREV 6/30/2018 23:38'!supplierMapping	^ ClassMapping		withDefaultTableNameFor: Supplier		mappingAll:			(Array				with: (EmbededMapping withDefaultFieldNameFor: #name)				with: (EmbededMapping withDefaultFieldNameFor: #identificationType)				with: (EmbededMapping withDefaultFieldNameFor: #identificationNumber)				with: (OneToManyMapping withDefaultFieldNameFor: #addresses ofType: Address)				with: (OneToManyMapping withDefaultFieldNameFor: #customers ofType: Customer))! !!PersistentSupplierSystem methodsFor: 'transaction' stamp: 'LREV 7/1/2018 00:01'!beginTransaction	customerSystem  beginTransaction! !!PersistentSupplierSystem methodsFor: 'transaction' stamp: 'LREV 7/1/2018 00:01'!commit	customerSystem  commit! !Object subclass: #RecordParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!RecordParser methodsFor: 'testing' stamp: 'LREV 6/30/2018 13:55'!isFor: aRecordID	self subclassResponsibility ! !!RecordParser methodsFor: 'testing' stamp: 'LREV 6/29/2018 20:20'!recordFieldsSize	self subclassResponsibility ! !!RecordParser methodsFor: 'parsing' stamp: 'LREV 6/30/2018 13:50'!parse: aRecord for: anObject	self subclassResponsibility ! !!RecordParser methodsFor: 'parsing' stamp: 'LREV 6/30/2018 14:23'!assertValidRecordSize: aRecordSize.		self subclassResponsibility ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!RecordParser class	instanceVariableNames: ''!!RecordParser class methodsFor: 'as yet unclassified' stamp: 'LREV 6/30/2018 14:25'!invalidRecordSizeErrorDescription	self subclassResponsibility ! !RecordParser subclass: #AddressRecordParser	instanceVariableNames: 'recordFieldsSize system recordID'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!AddressRecordParser methodsFor: 'initialization' stamp: 'LREV 7/1/2018 20:38'!initializeFor: aRecordID.	recordID := aRecordID.	recordFieldsSize := 6.! !!AddressRecordParser methodsFor: 'testing' stamp: 'LREV 6/30/2018 13:55'!isFor: aRecordID	^ (recordID = aRecordID)! !!AddressRecordParser methodsFor: 'testing' stamp: 'LREV 6/29/2018 20:21'!recordFieldsSize	^recordFieldsSize copy! !!AddressRecordParser methodsFor: 'parsing' stamp: 'LREV 6/30/2018 14:20'!parse: anAddressRecord for: aCSVImporter	|newAddress|		self assertValidRecordSize: anAddressRecord size.		newAddress := Address new.	newAddress streetName: anAddressRecord second.	newAddress streetNumber: anAddressRecord third asInteger.	newAddress town: anAddressRecord fourth.	newAddress zipCode: anAddressRecord fifth asInteger.	newAddress province: anAddressRecord sixth.		aCSVImporter importAddress: newAddress.! !!AddressRecordParser methodsFor: 'parsing' stamp: 'LREV 6/30/2018 14:23'!assertValidRecordSize: aRecordSize.		(recordFieldsSize = aRecordSize) ifFalse: [ self error: self class invalidRecordSizeErrorDescription]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AddressRecordParser class	instanceVariableNames: ''!!AddressRecordParser class methodsFor: 'testing' stamp: 'LREV 7/1/2018 20:38'!for: aRecordID	^ self new initializeFor: aRecordID! !!AddressRecordParser class methodsFor: 'as yet unclassified' stamp: 'LREV 6/30/2018 14:25'!invalidRecordSizeErrorDescription	^'Invalid address record'! !RecordParser subclass: #CustomerRecordParser	instanceVariableNames: 'recordFieldsSize system recordID'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!CustomerRecordParser methodsFor: 'testing' stamp: 'LREV 6/30/2018 13:55'!isFor: aRecordID	^ (recordID = aRecordID)! !!CustomerRecordParser methodsFor: 'testing' stamp: 'LREV 6/29/2018 20:21'!recordFieldsSize	^recordFieldsSize copy! !!CustomerRecordParser methodsFor: 'initialization' stamp: 'LREV 7/1/2018 20:38'!initializeFor: aRecordID.	recordID := aRecordID.	recordFieldsSize := 5.! !!CustomerRecordParser methodsFor: 'parsing' stamp: 'LREV 6/30/2018 14:32'!parse: aCustomerRecord for: aCSVImporter	| customer |	self assertValidRecordSize: aCustomerRecord size.	customer := Customer new.	customer firstName: aCustomerRecord second.	customer lastName: aCustomerRecord third.	customer identificationType: aCustomerRecord fourth.	customer identificationNumber: aCustomerRecord fifth.		aCSVImporter importCustomer: customer.		! !!CustomerRecordParser methodsFor: 'parsing' stamp: 'LREV 6/30/2018 14:23'!assertValidRecordSize: aRecordSize.		(recordFieldsSize = aRecordSize) ifFalse: [ self error: self class invalidRecordSizeErrorDescription]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CustomerRecordParser class	instanceVariableNames: ''!!CustomerRecordParser class methodsFor: 'testing' stamp: 'LREV 7/1/2018 20:38'!for: aRecordID	^ self new initializeFor: aRecordID! !!CustomerRecordParser class methodsFor: 'as yet unclassified' stamp: 'LREV 6/30/2018 14:25'!invalidRecordSizeErrorDescription	^'Invalid customer record'! !RecordParser subclass: #ExistingCustomerRecordParser	instanceVariableNames: 'recordFieldsSize system recordID'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!ExistingCustomerRecordParser methodsFor: 'testing' stamp: 'LREV 6/30/2018 13:55'!isFor: aRecordID	^ (recordID = aRecordID)! !!ExistingCustomerRecordParser methodsFor: 'testing' stamp: 'LREV 6/30/2018 14:17'!recordFieldsSize	^recordFieldsSize copy! !!ExistingCustomerRecordParser methodsFor: 'initialization' stamp: 'LREV 7/1/2018 20:38'!initializeFor: aRecordID.	recordID := aRecordID.	recordFieldsSize := 3.! !!ExistingCustomerRecordParser methodsFor: 'parsing' stamp: 'LREV 6/30/2018 14:32'!parse: anExistingCustomerRecord for: aCSVImporter		self assertValidRecordSize: anExistingCustomerRecord  size.	aCSVImporter getCustomerForSupplier.! !!ExistingCustomerRecordParser methodsFor: 'parsing' stamp: 'LREV 6/30/2018 14:23'!assertValidRecordSize: aRecordSize.		(recordFieldsSize = aRecordSize) ifFalse: [ self error: self class invalidRecordSizeErrorDescription]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ExistingCustomerRecordParser class	instanceVariableNames: ''!!ExistingCustomerRecordParser class methodsFor: 'instance creation' stamp: 'LREV 7/1/2018 20:38'!for: aRecordID	^ self new initializeFor: aRecordID! !!ExistingCustomerRecordParser class methodsFor: 'as yet unclassified' stamp: 'LREV 6/30/2018 14:26'!invalidRecordSizeErrorDescription	^'Invalid customer record'! !Party subclass: #Supplier	instanceVariableNames: 'name customers id identificationType identificationNumber addresses'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!Supplier methodsFor: 'customers' stamp: 'LREV 6/30/2018 20:44'!customerIdentifiedAs: anIDType numbered: anIDNumber ifNone: aClosureForAbsence		^customers detect: [ :aCustomer | (aCustomer identificationType = anIDType) and:  [ aCustomer identificationNumber = anIDNumber ]   ] ifNone: [ aClosureForAbsence  value ]! !!Supplier methodsFor: 'name' stamp: 'LREV 6/28/2018 20:03'!name	^name copy.! !!Supplier methodsFor: 'name' stamp: 'LREV 6/28/2018 20:03'!name: aName	name := aName.! !!Supplier methodsFor: 'initialization' stamp: 'LREV 6/28/2018 20:21'!initialize	customers := OrderedCollection new.	addresses := OrderedCollection new.! !!Supplier methodsFor: 'addresses' stamp: 'LREV 6/29/2018 19:58'!addresses	^ addresses copy.! !!Supplier methodsFor: 'addresses' stamp: 'LREV 6/29/2018 19:59'!addAddress: anAddress 	addresses add: anAddress ! !!Supplier methodsFor: 'addresses' stamp: 'LREV 6/29/2018 19:59'!addressAt: aStreetName ifNone: noneClosure 		^addresses detect: [ :anAddress | anAddress isAt: aStreetName ] ifNone: noneClosure ! !!Supplier methodsFor: 'as yet unclassified' stamp: 'LREV 6/28/2018 20:22'!customers	^ customers copy! !!Supplier methodsFor: 'as yet unclassified' stamp: 'LREV 6/28/2018 20:20'!addCustomer: aCustomer 	customers add: aCustomer.! !!Supplier methodsFor: 'identification' stamp: 'LREV 6/28/2018 19:42'!identificationNumber: anIDNumberidentificationNumber := anIDNumber ! !!Supplier methodsFor: 'identification' stamp: 'LREV 6/28/2018 19:56'!identificationNumber	^identificationNumber copy! !!Supplier methodsFor: 'identification' stamp: 'LREV 6/28/2018 19:55'!identificationType	^identificationType copy! !!Supplier methodsFor: 'identification' stamp: 'LREV 6/28/2018 19:56'!identificationType: anIDType 	identificationType  := anIDType ! !TestCase subclass: #SupplierImportTest	instanceVariableNames: 'importer system recordParsers'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!SupplierImportTest methodsFor: 'assertions' stamp: 'LREV 6/30/2018 21:17'!assertSystemWithOnlyOneValidSupplier	| supplier |	self assert: system allSuppliers size equals: 1.	self assert: system allCustomers size equals: 0.	supplier := system supplierIdentifiedAs: 'D' numbered: '123'.	self assert: supplier name equals: 'Supplier1'.	self assert: supplier customers size equals: 0.	^ self assert: supplier addresses size equals: 0! !!SupplierImportTest methodsFor: 'assertions' stamp: 'LREV 6/30/2018 22:19'!assertValidSupplierWithAddressWasImportedCorrectly	| supplierAddress supplier |	supplier := self assertValidSupplierCorrectlyImported .	self assert: supplier customers size equals: 0.	self assert: supplier addresses size equals: 1.	supplierAddress := supplier		addressAt: 'San Martin'		ifNone: [ self fail ].	self assert: supplierAddress streetNumber equals: 3322.	self assert: supplierAddress town equals: 'Olivos'.	self assert: supplierAddress zipCode equals: 1636.	self assert: supplierAddress province equals: 'BsAs'! !!SupplierImportTest methodsFor: 'assertions' stamp: 'LREV 7/1/2018 20:39'!assertSystemIncludesCustomer: aCustomerInSystem	| customerInDB |	customerInDB := system		customerIdentifiedAs: aCustomerInSystem identificationType 		numbered: aCustomerInSystem identificationNumber 		ifNone: [ self error: 'Customer not Imported' ].	self assert: customerInDB firstName equals: aCustomerInSystem firstName .	self assert: customerInDB lastName equals: aCustomerInSystem lastName ! !!SupplierImportTest methodsFor: 'assertions' stamp: 'LREV 6/30/2018 21:12'!assertValidSupplierCorrectlyImported	| supplier |	self assert: system allSuppliers size equals: 1.	supplier := system supplierIdentifiedAs: 'D' numbered: '123'.	self assert: supplier name equals: 'Supplier1'.	^supplier! !!SupplierImportTest methodsFor: 'assertions' stamp: 'LREV 6/30/2018 22:42'!assertOnlyValidSupplierCorrectlyImported	| supplier |	supplier := self assertValidSupplierCorrectlyImported.	self assert: supplier addresses size equals: 0.	self assert: supplier customers size equals: 0! !!SupplierImportTest methodsFor: 'assertions' stamp: 'LREV 7/1/2018 20:39'!assertOnlyExistingCustomerInSystem	self assert: system allSuppliers size equals: 0.	^ self assertSystemIncludesCustomer: self existingCustomer! !!SupplierImportTest methodsFor: 'assertions' stamp: 'LREV 6/30/2018 22:36'!assertSystemIsEmpty	self assert: system allSuppliers size equals: 0.	^ self assert: system allCustomers size equals: 0! !!SupplierImportTest methodsFor: 'assertions' stamp: 'LREV 6/30/2018 22:33'!assertValidSupplierWasImportedCorrectlyWithCustomer: anImportedCustomer	| supplier customer |	supplier := self assertValidSupplierCorrectlyImported.	customer := supplier		customerIdentifiedAs: anImportedCustomer  identificationType 		numbered: anImportedCustomer identificationNumber 		ifNone: [ self error: 'Customer not Imported' ].	self assert: customer firstName equals: anImportedCustomer firstName.	self assert: customer lastName equals: anImportedCustomer lastName.! !!SupplierImportTest methodsFor: 'testing' stamp: 'LREV 7/1/2018 23:20'!test02CanAddANewCustomerToASupplier	self importSuppliersFrom: self supplierWithNewCustomerValidStream.	self		assertValidSupplierWasImportedCorrectlyWithCustomer: self newCustomer! !!SupplierImportTest methodsFor: 'testing' stamp: 'LREV 7/1/2018 20:39'!test16CanNotAddNewCustomerRecordIfItAlreadyExistsInSystem	self addNewCustomerToSystem.	self		importing: self supplierWithNewCustomerValidStream		raises: SupplierImporter customerAlreadyInSystemErrorDescription		asserting: [ self assertOnlyValidSupplierCorrectlyImported.			self assertSystemIncludesCustomer: self newCustomer ]! !!SupplierImportTest methodsFor: 'testing' stamp: 'LREV 6/30/2018 23:08'!test05CanNotImportSuppliersWithMoreFieldsThanRequired	self		importing: self supplierWithMoreFieldsStream		raises: SupplierImporter invalidSupplierRecordErrorDescription		asserting: [self assertSystemIsEmpty  ]! !!SupplierImportTest methodsFor: 'testing' stamp: 'LREV 7/1/2018 20:40'!test12bCanNotAddAddressWithoutASupplier	self		importing: self addressWithoutSupplierStream 		raises: SupplierImporter addressWithoutSupplierErrorDescription		asserting: [ 	self assertSystemIsEmpty ]! !!SupplierImportTest methodsFor: 'testing' stamp: 'LREV 6/30/2018 23:06'!test07CanNotImportAddressWithMoreFieldsThanRequired	self		importing:  self addressWithMoreFieldsStream		raises: SupplierImporter invalidAddressRecordErrorDescription		asserting: [ self assertSystemWithOnlyOneValidSupplier ]! !!SupplierImportTest methodsFor: 'testing' stamp: 'LREV 6/30/2018 23:07'!test06CanNotImportAddressWithLessFieldsThanRequired	self		importing: self addressWithLessFieldsStream		raises: SupplierImporter invalidAddressRecordErrorDescription		asserting: [self assertSystemWithOnlyOneValidSupplier ]! !!SupplierImportTest methodsFor: 'testing' stamp: 'LREV 6/30/2018 23:02'!test15ShouldNotImportSupplierRecordWithMoreThanAnS	self		importing: self invalidSupplierTypeStream		raises: SupplierImporter invalidRecordTypeErrorDescription		asserting: [ self assertSystemIsEmpty  ].! !!SupplierImportTest methodsFor: 'testing' stamp: 'LREV 6/30/2018 23:04'!test12CanNotAddExistingCustomerWithoutASupplier	self addExistingCustomerToSystem.	self		importing: self existingCustomerWithoutSupplierStream		raises: SupplierImporter customerWithoutSupplierErrorDescription		asserting: [self assertOnlyExistingCustomerInSystem ]! !!SupplierImportTest methodsFor: 'testing' stamp: 'LREV 6/30/2018 23:04'!test11CanNotAddNewCustomerWithoutASupplier	self		importing: self newCustomerWithoutSupplierStream 		raises: SupplierImporter customerWithoutSupplierErrorDescription		asserting:	[self assertSystemIsEmpty]! !!SupplierImportTest methodsFor: 'testing' stamp: 'LREV 6/30/2018 23:03'!test13ShouldNotImportAddressRecordWithMoreThanAnA	self		importing: self invalidAddressTypeStream		raises: SupplierImporter invalidRecordTypeErrorDescription		asserting: [ self assertSystemWithOnlyOneValidSupplier ]! !!SupplierImportTest methodsFor: 'testing' stamp: 'LREV 6/30/2018 23:05'!test10emptyLinesAreRecognizedAsInvalidRecords	self		importing: self streamWithEmptyLine		raises: SupplierImporter invalidRecordTypeErrorDescription		asserting: 	[self assertSystemIsEmpty  ]! !!SupplierImportTest methodsFor: 'testing' stamp: 'LREV 6/30/2018 23:08'!test05CanNotImportSuppliersWithLessFieldsThanRequired	self		importing: self supplierWithLessFieldsStream		raises: SupplierImporter invalidSupplierRecordErrorDescription		asserting: [ 	self assertSystemIsEmpty ]! !!SupplierImportTest methodsFor: 'testing' stamp: 'LREV 6/30/2018 23:01'!test17CanNotAddExistingCustomerRecordIfNotInSystem	self		importing:  self supplierWithExistingCustomerValidStream 		raises: SupplierImporter customerNotInSystemErrorDescription		asserting: [ self assertSystemWithOnlyOneValidSupplier ].! !!SupplierImportTest methodsFor: 'testing' stamp: 'LREV 6/30/2018 23:06'!test08CanNotAddNewCustomerRecordToSuppliersWithMoreFieldsThanRequired	self		importing: self newCustomerWithMoreFieldsStream		raises: SupplierImporter invalidCustomerRecordErrorDescription		asserting: [ 	self assertSystemWithOnlyOneValidSupplier ]! !!SupplierImportTest methodsFor: 'testing' stamp: 'LREV 7/1/2018 20:39'!test03CanAddAnExistingCustomerToASupplier	self addExistingCustomerToSystem.	self		importSuppliersFrom: self supplierWithExistingCustomerValidStream.	self		assertValidSupplierWasImportedCorrectlyWithCustomer: self existingCustomer.	self assertSystemIncludesCustomer: self existingCustomer! !!SupplierImportTest methodsFor: 'testing' stamp: 'LREV 7/1/2018 20:39'!test01CanImportValidSupplier	self importSuppliersFrom: self supplierValidStream.	self assertOnlyValidSupplierCorrectlyImported ! !!SupplierImportTest methodsFor: 'testing' stamp: 'LREV 6/30/2018 23:02'!test14ShouldNotImportCustomerRecordWithOtherThanNCorEC	self		importing:  self invalidCustomerTypeStream		raises: SupplierImporter invalidRecordTypeErrorDescription		asserting: [ self assertSystemWithOnlyOneValidSupplier ]! !!SupplierImportTest methodsFor: 'testing' stamp: 'LREV 6/30/2018 22:18'!test04CanAddAnAddressToASupplier	self importSuppliersFrom: self supplierWithAddressValidStream.	self assertValidSupplierWithAddressWasImportedCorrectly! !!SupplierImportTest methodsFor: 'testing' stamp: 'LREV 6/30/2018 23:05'!test09CanNotAddNewCustomerRecordToSuppliersWithLessFieldsThanRequired	self		importing:  self newCustomerWithLessFieldsStream		raises: SupplierImporter invalidCustomerRecordErrorDescription		asserting: [self assertSystemWithOnlyOneValidSupplier ]! !!SupplierImportTest methodsFor: 'test data' stamp: 'LREV 6/30/2018 22:27'!newCustomer	^ Customer		named: 'Pepe'		lastName: 'Sanchez'		identifiedAs: 'D'		numbered: '22333444'! !!SupplierImportTest methodsFor: 'test data' stamp: 'LREV 6/30/2018 20:51'!supplierWithLessFieldsStream	^ ReadStream on: 'S,Supplier1,D'! !!SupplierImportTest methodsFor: 'test data' stamp: 'LREV 6/30/2018 20:55'!addressWithoutSupplierStream	^ ReadStream on: 'A,San Martin,3322,Olivos,1636,BsAs'! !!SupplierImportTest methodsFor: 'test data' stamp: 'LREV 6/30/2018 20:50'!supplierWithExistingCustomerValidStream	^ ReadStream		on:			'S,Supplier1,D,123EC,D,5456774'! !!SupplierImportTest methodsFor: 'test data' stamp: 'LREV 6/30/2018 20:56'!invalidAddressTypeStream	^ ReadStream		on:			'S,Supplier1,D,123AA,San Martin,3322,Olivos,1636,BsAs'! !!SupplierImportTest methodsFor: 'test data' stamp: 'LREV 6/30/2018 20:49'!supplierWithNewCustomerValidStream	^ ReadStream		on:			'S,Supplier1,D,123NC,Pepe,Sanchez,D,22333444'! !!SupplierImportTest methodsFor: 'test data' stamp: 'LREV 6/30/2018 20:54'!streamWithEmptyLine	^ ReadStream		on:			''! !!SupplierImportTest methodsFor: 'test data' stamp: 'LREV 6/30/2018 22:27'!existingCustomer	^ Customer		named: 'Mauro'		lastName: 'Lopez'		identifiedAs: 'D'		numbered: '5456774'! !!SupplierImportTest methodsFor: 'test data' stamp: 'LREV 6/30/2018 20:52'!addressWithLessFieldsStream	^ ReadStream		on:			'S,Supplier1,D,123A,San Martin,3322,Olivos,1636'! !!SupplierImportTest methodsFor: 'test data' stamp: 'LREV 6/30/2018 20:53'!addressWithMoreFieldsStream	^ ReadStream		on:			'S,Supplier1,D,123A,San Martin,3322,Olivos,1636,BsAs,Argentina'! !!SupplierImportTest methodsFor: 'test data' stamp: 'LREV 6/30/2018 20:57'!invalidSupplierTypeStream	^ ReadStream on: 'SS,Supplier1,D,123'! !!SupplierImportTest methodsFor: 'test data' stamp: 'LREV 6/30/2018 20:56'!invalidCustomerTypeStream	^ ReadStream		on:			'S,Supplier1,D,123C,Pepe,Sanchez,D,22333444'! !!SupplierImportTest methodsFor: 'test data' stamp: 'LREV 6/30/2018 20:52'!supplierWithMoreFieldsStream	^ ReadStream on: 'S,Supplier1,D, 123, S'! !!SupplierImportTest methodsFor: 'test data' stamp: 'LREV 6/30/2018 20:54'!newCustomerWithLessFieldsStream	^ ReadStream		on:			'S,Supplier1,D,123NC,Pepe,Sanchez,D'! !!SupplierImportTest methodsFor: 'test data' stamp: 'LREV 6/30/2018 20:50'!supplierWithAddressValidStream	^ ReadStream		on:			'S,Supplier1,D,123A,San Martin,3322,Olivos,1636,BsAs'! !!SupplierImportTest methodsFor: 'test data' stamp: 'LREV 6/30/2018 20:53'!newCustomerWithMoreFieldsStream	^ ReadStream		on:			'S,Supplier1,D,123NC,Pepe,Sanchez,D,22333444,empleado'! !!SupplierImportTest methodsFor: 'test data' stamp: 'LREV 6/30/2018 20:55'!existingCustomerWithoutSupplierStream	^ ReadStream on: 'EC,D,5456774'! !!SupplierImportTest methodsFor: 'test data' stamp: 'LREV 6/30/2018 20:48'!supplierValidStream	^ ReadStream on: 'S,Supplier1,D,123'! !!SupplierImportTest methodsFor: 'test data' stamp: 'LREV 6/30/2018 20:54'!newCustomerWithoutSupplierStream	^ ReadStream on: 'NC,Pepe,Sanchez,D,22333444'! !!SupplierImportTest methodsFor: 'test support' stamp: 'LREV 6/30/2018 22:27'!addExistingCustomerToSystem	system add: self existingCustomer! !!SupplierImportTest methodsFor: 'test support' stamp: 'LREV 6/30/2018 22:59'!importing: aReadStream raises: anErrorMessage asserting: aBlockOfAssertions	self		should: [ self importSuppliersFrom: aReadStream  ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :error | 			self				assert: error messageText				equals: anErrorMessage .			aBlockOfAssertions value. ]! !!SupplierImportTest methodsFor: 'test support' stamp: 'LREV 6/30/2018 22:27'!addNewCustomerToSystem	system add: self newCustomer! !!SupplierImportTest methodsFor: 'test support' stamp: 'LREV 7/1/2018 21:44'!importSuppliersFrom: aReadStream	(SupplierImporter from: aReadStream using: system) import! !!SupplierImportTest methodsFor: 'setUp - tearDown' stamp: 'LREV 6/30/2018 23:17'!setUp	system := Environment current createSupplierSystem.	system start.	system beginTransaction.	recordParsers := Array		with: (AddressRecordParser for: 'A')		with: (CustomerRecordParser for: 'NC')		with: (ExistingCustomerRecordParser for: 'EC')		with: (SupplierRecordParser for: 'S')! !!SupplierImportTest methodsFor: 'setUp - tearDown' stamp: 'LREV 6/28/2018 19:29'!tearDown	system commit.	system shutdown! !CSVImporter subclass: #SupplierImporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!SupplierImporter methodsFor: 'initialization' stamp: 'LREV 7/1/2018 21:45'!initializeOn: aReadStream using: aCustomerSystem	readStream := aReadStream.	system := aCustomerSystem.	recordParsers := Array		with: (AddressRecordParser for: 'A')		with: (CustomerRecordParser for: 'NC')		with: (ExistingCustomerRecordParser for: 'EC')		with: (SupplierRecordParser for: 'S').! !!SupplierImporter methodsFor: 'importing - private - supplier' stamp: 'LREV 6/30/2018 20:24'!importSupplier: aSupplier	newSupplier := aSupplier.	system add: newSupplier! !!SupplierImporter methodsFor: 'importing' stamp: 'LREV 7/1/2018 20:46'!import	[ self canImportNextLine ] whileTrue: [ 		self convertLineToRecord.		self importRecord ]! !!SupplierImporter methodsFor: 'signalling' stamp: 'LREV 6/29/2018 21:43'!signalCustomerWithoutSupplierError	self error: self class customerWithoutSupplierErrorDescription.! !!SupplierImporter methodsFor: 'signalling' stamp: 'LREV 6/29/2018 21:50'!signalCustomerAlreadyInSystem	self error: self class customerAlreadyInSystemErrorDescription ! !!SupplierImporter methodsFor: 'signalling' stamp: 'LREV 6/29/2018 21:46'!signalAddressWithoutSupplierError	self error: self class addressWithoutSupplierErrorDescription.! !!SupplierImporter methodsFor: 'signalling' stamp: 'LREV 6/29/2018 22:22'!signalCustomerNotInSystem	self error: self class customerNotInSystemErrorDescription.! !!SupplierImporter methodsFor: 'signalling' stamp: 'LREV 6/29/2018 20:42'!signalInvalidRecordType	self error: self class invalidRecordTypeErrorDescription! !!SupplierImporter methodsFor: 'asserting' stamp: 'LREV 7/1/2018 21:41'!assertCustomerNotInSupplier	newSupplier customerIdentifiedAs: record fourth 		numbered: record fifth		ifNone: [^self ].		self signalCustomerAlreadyInSystem.! !!SupplierImporter methodsFor: 'asserting' stamp: 'LREV 7/1/2018 21:41'!assertCustomerNotInSystem	| customer |	customer := system		customerIdentifiedAs: record fourth 		numbered: record fifth		ifNone: [^self  ].		self signalCustomerAlreadyInSystem! !!SupplierImporter methodsFor: 'asserting' stamp: 'LREV 6/29/2018 21:46'!assertThereIsSupplierForAddress	newSupplier isNil ifTrue: [ self signalAddressWithoutSupplierError ].! !!SupplierImporter methodsFor: 'asserting' stamp: 'LREV 6/29/2018 21:22'!assertThereIsSupplierForCustomer	newSupplier isNil ifTrue: [ self signalCustomerWithoutSupplierError ].! !!SupplierImporter methodsFor: 'asserting' stamp: 'LREV 6/29/2018 20:36'!assertRecordNotEmpty		record isEmpty ifTrue: [ self signalInvalidRecordType ]! !!SupplierImporter methodsFor: 'importing - private' stamp: 'LREV 6/30/2018 14:40'!importRecord|parser|	parser := recordParsers		detect: [ :aRecordParser | aRecordParser isFor: record first ] ifNone: [self signalInvalidRecordType].			parser parse: record for: self.! !!SupplierImporter methodsFor: 'importing - private' stamp: 'LREV 7/1/2018 20:46'!canImportNextLine	line := readStream nextLine.	^ line notNil! !!SupplierImporter methodsFor: 'importing - private' stamp: 'LREV 7/1/2018 20:47'!convertLineToRecord	record := line substrings: {$,}.		self assertRecordNotEmpty! !!SupplierImporter methodsFor: 'importing - private - customer' stamp: 'LREV 6/29/2018 22:21'!getCustomerForSupplier	| customer |	self assertThereIsSupplierForCustomer.	customer := system		customerIdentifiedAs: record second		numbered: record third		ifNone: [ self signalCustomerNotInSystem ].	newSupplier addCustomer: customer! !!SupplierImporter methodsFor: 'importing - private - customer' stamp: 'LREV 6/30/2018 15:57'!importCustomer: aCustomer	self assertThereIsSupplierForCustomer.	self assertCustomerNotInSystem.	self assertCustomerNotInSupplier.	newSupplier addCustomer: aCustomer.	"system add: aCustomer."! !!SupplierImporter methodsFor: 'importing - private - address' stamp: 'LREV 6/30/2018 14:01'!importAddress: anAddress	self assertThereIsSupplierForAddress.	newSupplier addAddress: anAddress! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SupplierImporter class	instanceVariableNames: ''!!SupplierImporter class methodsFor: 'as yet unclassified' stamp: 'LREV 6/29/2018 21:23'!customerWithoutSupplierErrorDescription	^'There is no supplier for the imported customer'! !!SupplierImporter class methodsFor: 'as yet unclassified' stamp: 'LREV 6/29/2018 21:40'!customerAlreadyInSystemErrorDescription	^'Duplicated customer can not be added'! !!SupplierImporter class methodsFor: 'as yet unclassified' stamp: 'LREV 6/29/2018 20:29'!invalidSupplierRecordErrorDescription	^'Invalid supplier record'! !!SupplierImporter class methodsFor: 'as yet unclassified' stamp: 'LREV 6/29/2018 22:22'!customerNotInSystemErrorDescription	^'Customer not found'! !!SupplierImporter class methodsFor: 'as yet unclassified' stamp: 'LREV 6/29/2018 21:46'!addressWithoutSupplierErrorDescription	^'There is no supplier for the imported address'! !!SupplierImporter class methodsFor: 'error descriptions' stamp: 'LREV 6/29/2018 20:40'!invalidCustomerRecordErrorDescription		^'Invalid customer record'! !!SupplierImporter class methodsFor: 'error descriptions' stamp: 'LREV 6/29/2018 20:40'!invalidRecordTypeErrorDescription		^'Invalid record type'! !!SupplierImporter class methodsFor: 'error descriptions' stamp: 'LREV 6/29/2018 20:40'!invalidAddressRecordErrorDescription		^'Invalid address record'! !!SupplierImporter class methodsFor: 'instance creation' stamp: 'LREV 7/1/2018 21:45'!from: aReadStream using: aCustomerSystem	^ self new initializeOn: aReadStream using: aCustomerSystem! !RecordParser subclass: #SupplierRecordParser	instanceVariableNames: 'recordFieldsSize system recordID'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!SupplierRecordParser methodsFor: 'testing' stamp: 'LREV 6/30/2018 13:55'!isFor: aRecordID	^ (recordID = aRecordID)! !!SupplierRecordParser methodsFor: 'testing' stamp: 'LREV 6/30/2018 14:17'!recordFieldsSize	^recordFieldsSize copy! !!SupplierRecordParser methodsFor: 'parsing' stamp: 'LREV 6/30/2018 14:33'!parse: aSupplierRecord for: aCSVImporter	|newSupplier|	self assertValidRecordSize: aSupplierRecord size.	newSupplier := Supplier new.	newSupplier name: aSupplierRecord second.	newSupplier identificationType: aSupplierRecord third.	newSupplier identificationNumber: aSupplierRecord fourth .		aCSVImporter importSupplier: newSupplier! !!SupplierRecordParser methodsFor: 'parsing' stamp: 'LREV 6/30/2018 14:23'!assertValidRecordSize: aRecordSize.		(recordFieldsSize = aRecordSize) ifFalse: [ self error: self class invalidRecordSizeErrorDescription]! !!SupplierRecordParser methodsFor: 'initialization' stamp: 'LREV 7/1/2018 20:38'!initializeFor: aRecordID.	recordID := aRecordID.	recordFieldsSize := 4.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SupplierRecordParser class	instanceVariableNames: ''!!SupplierRecordParser class methodsFor: 'testing' stamp: 'LREV 7/1/2018 20:38'!for: aRecordID	^ self new initializeFor: aRecordID! !!SupplierRecordParser class methodsFor: 'as yet unclassified' stamp: 'LREV 6/30/2018 14:25'!invalidRecordSizeErrorDescription	^'Invalid supplier record'! !ERPSystem subclass: #TransientCustomerSystem	instanceVariableNames: 'customers suppliers'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!TransientCustomerSystem methodsFor: 'customers' stamp: 'HernanWilkinson 11/4/2016 09:39'!allCustomers	^ customers copy! !!TransientCustomerSystem methodsFor: 'customers' stamp: 'HernanWilkinson 11/4/2016 09:40'!customersIsEmpty	^ customers isEmpty ! !!TransientCustomerSystem methodsFor: 'customers' stamp: 'LREV 6/29/2018 22:18'!customerIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber ifNone: aDefaultBlock		^customers detect: [ :aCustomer | aCustomer isIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber ] ifNone: [aDefaultBlock value]! !!TransientCustomerSystem methodsFor: 'customers' stamp: 'LREV 6/30/2018 23:35'!add: aParty	^customers add: aParty! !!TransientCustomerSystem methodsFor: 'system live cycle' stamp: 'HernanWilkinson 11/4/2016 09:52'!shutdown		! !!TransientCustomerSystem methodsFor: 'system live cycle' stamp: 'HernanWilkinson 11/4/2016 09:51'!start	! !!TransientCustomerSystem methodsFor: 'transaction' stamp: 'HernanWilkinson 11/4/2016 09:39'!beginTransaction		! !!TransientCustomerSystem methodsFor: 'transaction' stamp: 'HernanWilkinson 11/4/2016 09:39'!commit		! !!TransientCustomerSystem methodsFor: 'initialization' stamp: 'LREV 6/30/2018 23:35'!initialize		customers := OrderedCollection new.! !ERPSystem subclass: #TransientSupplierSystem	instanceVariableNames: 'customerSystem suppliers'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!TransientSupplierSystem methodsFor: 'suppliers' stamp: 'LREV 6/30/2018 23:33'!supplierIdentifiedAs: anIDType numbered: anIDNumber 	^suppliers detect: [ :aSupplier | (aSupplier identificationType = anIDType) and: [ aSupplier identificationNumber = anIDNumber  ] ] ifNone: [ self error: self class supplierNotInSystemErrorMsg ]! !!TransientSupplierSystem methodsFor: 'suppliers' stamp: 'LREV 6/30/2018 23:32'!allSuppliers	^ suppliers copy.! !!TransientSupplierSystem methodsFor: 'transaction' stamp: 'LREV 6/30/2018 23:20'!beginTransaction	customerSystem beginTransaction ! !!TransientSupplierSystem methodsFor: 'transaction' stamp: 'LREV 6/30/2018 23:27'!commit	customerSystem commit.! !!TransientSupplierSystem methodsFor: 'customers' stamp: 'LREV 6/30/2018 23:30'!allCustomers	^customerSystem allCustomers ! !!TransientSupplierSystem methodsFor: 'customers' stamp: 'LREV 6/30/2018 23:30'!customerIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber ifNone: anObject	^customerSystem customerIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber ifNone: anObject.! !!TransientSupplierSystem methodsFor: 'customers' stamp: 'LREV 6/30/2018 23:32'!add: aParty	(aParty isKindOf: Supplier) ifTrue: [ ^suppliers add: aParty  ]. 	customerSystem add: aParty ! !!TransientSupplierSystem methodsFor: 'system live cycle' stamp: 'LREV 6/30/2018 23:34'!initialize	customerSystem := TransientCustomerSystem new.	suppliers := OrderedCollection new.! !!TransientSupplierSystem methodsFor: 'system live cycle' stamp: 'LREV 6/30/2018 23:27'!shutdown	customerSystem shutdown ! !!TransientSupplierSystem methodsFor: 'system live cycle' stamp: 'LREV 6/30/2018 23:20'!start	customerSystem start.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TransientSupplierSystem class	instanceVariableNames: ''!!TransientSupplierSystem class methodsFor: 'as yet unclassified' stamp: 'LREV 6/30/2018 23:36'!supplierNotInSystemErrorMsg	^'Supplier not in system'! !Object subclass: #ClassMapping	instanceVariableNames: 'mappedClass mappings tableName'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-PersistanceModel'!!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:40'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession	mappings do: [ :aMapping | aMapping mapOneToManyRelationshipsOf: anObject using: aDataBaseSession ]! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:43'!unmap: aRecord into: unMappedObject using: aDataBaseSession	mappings do: [ :aMapping | aMapping unmap: aRecord into: unMappedObject using: aDataBaseSession ]! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:43'!unmapIdOf: aRecord into: unMappedObject	unMappedObject instVarNamed: #id put: (aRecord at: #id)! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:40'!mapEmbededOf: anObject into: record	mappings do: [ :aMapping | aMapping embeded: anObject into: record ]! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:40'!mapIdOf: anObject into: record using: aDataBaseSession	| newId |	newId := aDataBaseSession newIdFor: anObject.	anObject instVarNamed: #id put: newId.	record at: #id put: newId! !!ClassMapping methodsFor: 'table' stamp: 'HernanWilkinson 10/31/2016 23:25'!tableName		^tableName ! !!ClassMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 00:40'!map: anObject using: aDataBaseSession	| record |	self toDo: 'se puede optimizar usando array para registros y guardando definicion de tabla una vez'.	record := Dictionary new.		self mapIdOf: anObject into: record using: aDataBaseSession.	self mapEmbededOf: anObject into: record.	"agrego aca el registro y no luego de mapear el id para que lo agrege completo. Lo agrego antes de mapear las rel one to many 	porque si usuara una db de verdad habria foreign key constrain"	aDataBaseSession add: record on: self tableName.	self mapOneToManyRelationshipsOf: anObject using: aDataBaseSession! !!ClassMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 00:42'!unmap: aRecord using: aDataBaseSession	| unMappedObject |	unMappedObject := mappedClass basicNew.	self unmapIdOf: aRecord into: unMappedObject.	self unmap: aRecord into: unMappedObject using: aDataBaseSession.	^ unMappedObject! !!ClassMapping methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 23:25'!initializeFor: aClass into: aTableName mappingAll: aCollectionOfMappings	mappedClass := aClass.	tableName := aTableName.	mappings := aCollectionOfMappings ! !!ClassMapping methodsFor: 'testing' stamp: 'HernanWilkinson 10/31/2016 23:02'!isFor: aClass	^mappedClass = aClass! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ClassMapping class	instanceVariableNames: ''!!ClassMapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 21:15'!assertHasIdInstanceVariable: aClass 		(aClass hasInstVarNamed: #id) ifFalse: [ self error: ('<1s> has no id instance variable' expandMacrosWith: aClass name) ]! !!ClassMapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 19:26'!assertValidMappings: aCollectionOfMappings for: aClass 	self toDo: 'Lo mejor seria recolectar todos los erroes de mapeo y no parar en el primero'.	aCollectionOfMappings do: [ :aMapping | aMapping assertIsValidFor: aClass ]	! !!ClassMapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 23:41'!assertValidTableName: aTableName	aTableName trimBoth isEmpty ifTrue: [ self error: 'Table name can not be empty' ]! !!ClassMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 11/1/2016 00:44'!defaultTableNameFor: aClass		^aClass name asString! !!ClassMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:24'!for: aClass into: aTableName mappingAll: aCollectionOfMappings	self assertValidTableName: aTableName.	self assertHasIdInstanceVariable: aClass.	self assertValidMappings: aCollectionOfMappings for: aClass.		^self new initializeFor: aClass into: aTableName mappingAll: aCollectionOfMappings		! !!ClassMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:23'!withDefaultTableNameFor: aClass mappingAll: aCollectionOfMappings	^self for: aClass into: (self defaultTableNameFor: aClass) mappingAll: aCollectionOfMappings		! !Object subclass: #DataBaseSession	instanceVariableNames: 'configuration tables id cache'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-PersistanceModel'!!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:55'!assertNotInTransasction		cache notNil ifTrue: [ self error: 'There is an open transaction already' ]! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:55'!assertInTransaction		cache isNil ifTrue: [ self error: 'There is no transaction currently' ]! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:57'!beginTransaction	self assertIsOpen.	self assertNotInTransasction.		cache := WeakKeyDictionary new.	! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:57'!commit		self assertInTransaction.		cache := nil! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:03'!add: aRecord on: aTableName	| table existingRecord |	table := self tableNamed: aTableName.	existingRecord := table at: (self recordId: aRecord) ifAbsentPut: [ aRecord ].	existingRecord == aRecord ifFalse: [ self error: 'Duplicated primary key' ]! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:05'!assertRelationOwnedBy: anOwner isUniqueFor: aRelated identifiedAs: relatedId in: relatedIds	(relatedIds includes: relatedId) ifTrue: [ self signalRelationAlreadyExistBetween: anOwner and: aRelated ]! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:06'!relatedIdOwnedBy: anOwner on: table	^ table at: (self idOf: anOwner) ifAbsentPut: [ Set new ]! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:00'!signalRelationAlreadyExistBetween: anOwner and: aRelated 	self error: ('Relation between id <1s> of type <2s> and id <3s> of type <4s> already exist'		expandMacrosWith: (self idOf: anOwner) printString		with: anOwner class name		with: (self idOf: aRelated) printString		with: aRelated class name)! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:10'!relatedIdsOwnedBy: anOwner forType: aRelatedClass	| relatedIds table |	table := self relationTableFor: anOwner class relatedTo: aRelatedClass.	relatedIds := self relatedIdOwnedBy: anOwner on: table.		^ relatedIds! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:03'!addRelated: aRelated ownedBy: anOwner	| relatedIds relatedId |	relatedIds := self relatedIdsOwnedBy: anOwner forType: aRelated class.	relatedId := aRelated instVarNamed: #id.	self assertRelationOwnedBy: anOwner isUniqueFor: aRelated identifiedAs: relatedId in: relatedIds.		relatedIds add: relatedId! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:27'!addToCache: anObject 	cache at: (self idOf: anObject) put: anObject ! !!DataBaseSession methodsFor: 'selecting' stamp: 'HernanWilkinson 11/1/2016 01:15'!objectIdentifiedAs: anId ofType: aClass	self assertInTransaction.	self delay.		^ cache at: anId ifAbsentPut: [ self unmapRecordIdentifiedAs: anId ofType: aClass ]! !!DataBaseSession methodsFor: 'selecting' stamp: 'HernanWilkinson 11/1/2016 01:26'!select: aCondition ofType: aClass	| mapper table |	self assertInTransaction.	self delay.		mapper := self mapperFor: aClass.	table := tables at: mapper tableName ifAbsent: [ ^ #() ].		^ table inject: OrderedCollection new into: [ :selected :record | self addInto: selected theOnesThatHold: aCondition unmapping: record with: mapper ]! !!DataBaseSession methodsFor: 'selecting' stamp: 'HernanWilkinson 10/31/2016 22:17'!selectAllOfType: aClass 		^self select: [ :anObject | true ] ofType: aClass! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 11/4/2016 09:52'!shutdown	self assertIsOpen.		tables := nil! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 11/4/2016 09:51'!start	self assertIsClose.		tables := Dictionary new.	! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 18:36'!assertIsOpen		tables isNil ifTrue: [ self error: 'Session must be open to colaborate with it' ]! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 18:37'!assertIsClose		tables isNil ifFalse: [ self error: 'Session must be close' ]! !!DataBaseSession methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 01:14'!mapperFor: aClass	self toDo: 'se puede mejorar performanco usando un dictionary'.	^configuration		detect: [ :aClassMapper | aClassMapper isFor: aClass ] 		ifNone: [ self error: ('There is no mapper for <1s>' expandMacrosWith: aClass name) ]! !!DataBaseSession methodsFor: 'mapping - private' stamp: 'LREV 7/1/2018 14:03'!unmapRecordIdentifiedAs: anId ofType: aClass	| record table mapper |	mapper := self mapperFor: aClass.	table := self tableNamed: mapper tableName.	record := table at: anId ifAbsent: [ self error: ('Object identified as <1s> does not exist' expandMacrosWith: anId printString) ].		^ mapper unmap: record using: self! !!DataBaseSession methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 01:15'!relatedOfType: aRelatedClass for: anOwner	| table relatedIds |		table := self relationTableFor: anOwner class relatedTo: aRelatedClass.	relatedIds := table at: (self idOf: anOwner) ifAbsent: [ ^#() ].		^relatedIds collect: [ :aRelatedId | self objectIdentifiedAs: aRelatedId ofType: aRelatedClass ]		! !!DataBaseSession methodsFor: 'tables - private' stamp: 'HernanWilkinson 11/1/2016 01:12'!relationTableFor: anOwnerClass relatedTo: aRelatedClass	| relationTableName table |	relationTableName := self relationTableNameOwnedBy: anOwnerClass relatedTo: aRelatedClass.	table := self tableNamed: relationTableName.		^ table! !!DataBaseSession methodsFor: 'tables - private' stamp: 'HernanWilkinson 11/1/2016 01:12'!relationTableNameOwnedBy: anOwnerClass relatedTo: aRelatedClass	| ownerClassMapper relatedClassMapper |		ownerClassMapper := self mapperFor: anOwnerClass.	relatedClassMapper := self mapperFor: aRelatedClass.		^ownerClassMapper tableName,'_', relatedClassMapper tableName asPlural.! !!DataBaseSession methodsFor: 'tables - private' stamp: 'HernanWilkinson 11/1/2016 00:48'!tableNamed: aTableName	^ tables at: aTableName ifAbsentPut: [ Dictionary new ]! !!DataBaseSession methodsFor: 'persistance' stamp: 'HernanWilkinson 11/1/2016 01:28'!persist: anObject	| mapper |		self assertInTransaction.	self delay.		mapper := self mapperFor: anObject class.	mapper map: anObject using: self.		self addToCache: anObject ! !!DataBaseSession methodsFor: 'selecting - private' stamp: 'HernanWilkinson 11/1/2016 01:28'!addInto: selected theOnesThatHold: aCondition unmapping: record with: mapper	| recordId aClassInstance |	recordId := self recordId: record.	aClassInstance := cache at: recordId ifAbsent: [ mapper unmap: record using: self ].	(aCondition value: aClassInstance) ifTrue: [ 		self addToCache: aClassInstance.		selected add: aClassInstance ].		^ selected! !!DataBaseSession methodsFor: 'id' stamp: 'HernanWilkinson 11/1/2016 01:00'!idOf: anObject	^anObject instVarNamed: #id! !!DataBaseSession methodsFor: 'id' stamp: 'HernanWilkinson 10/28/2016 16:35'!newIdFor: anObject	id := id + 1.	^id! !!DataBaseSession methodsFor: 'id' stamp: 'HernanWilkinson 11/1/2016 01:04'!recordId: aRecord	^aRecord at: #id! !!DataBaseSession methodsFor: 'persistence - private' stamp: 'HernanWilkinson 10/28/2016 16:35'!defineIdOf: anObject	anObject instVarNamed: 'id' put: (self newIdFor: anObject).! !!DataBaseSession methodsFor: 'persistence - private' stamp: 'HernanWilkinson 10/28/2016 16:41'!delay	(Delay forMilliseconds: 100) wait! !!DataBaseSession methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 22:55'!initializeFor: aConfiguration	configuration := aConfiguration.	id := 0.	tables := nil.	cache := nil.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DataBaseSession class	instanceVariableNames: ''!!DataBaseSession class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/28/2016 13:07'!for: aConfiguration	^self new initializeFor: aConfiguration! !Object subclass: #Mapping	instanceVariableNames: 'instanceVariableName'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-PersistanceModel'!!Mapping methodsFor: 'assertions' stamp: 'HernanWilkinson 11/1/2016 01:31'!assertIsValidFor: aClass 	(aClass hasInstVarNamed: instanceVariableName) ifFalse: [ 		self error: ('Invalid mapping for <1s> in class <2s>' expandMacrosWith: instanceVariableName with: aClass name) ] ! !!Mapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:26'!unmap: aRecord into: anObject using: aDataBaseSession	self subclassResponsibility! !!Mapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:26'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession	self subclassResponsibility! !!Mapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:26'!embeded: anObject into: aRecord	self subclassResponsibility! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Mapping class	instanceVariableNames: ''!!Mapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 11/1/2016 01:32'!defaultFieldNameFor: anInstanceVariableName	^anInstanceVariableName asString! !!Mapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 23:41'!assertValidFieldName: aFieldName	aFieldName trimBoth isEmpty ifTrue: [ self error: 'Field name can not be empty' ]! !Mapping subclass: #EmbededMapping	instanceVariableNames: 'fieldName'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-PersistanceModel'!!EmbededMapping methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 23:30'!initializeFor: anInstanceVariableName into: aFieldName	instanceVariableName := anInstanceVariableName.	fieldName := aFieldName ! !!EmbededMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:31'!unmap: aRecord into: anObject using: aDataBaseSession 	anObject instVarNamed: instanceVariableName put: (aRecord at: fieldName)! !!EmbededMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 21:23'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession 		! !!EmbededMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:31'!embeded: anObject into: aRecord	aRecord at: fieldName put: (anObject instVarNamed: instanceVariableName) ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EmbededMapping class	instanceVariableNames: ''!!EmbededMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:30'!for: anInstanceVariableName into: aFieldName	^self new initializeFor: anInstanceVariableName into: aFieldName ! !!EmbededMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:29'!withDefaultFieldNameFor: anInstanceVariableName	^self for: anInstanceVariableName into: (self defaultFieldNameFor: anInstanceVariableName)! !Mapping subclass: #OneToManyMapping	instanceVariableNames: 'relatedType fieldName'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-PersistanceModel'!!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 01:37'!unmap: aRecord into: anObject using: aDataBaseSession	| newCollection related |	related := aDataBaseSession relatedOfType: relatedType for: anObject.	newCollection := self createRelationCollectionOn: aDataBaseSession ownedBy: anObject.	newCollection addAllNotPersisting: related.	anObject instVarNamed: instanceVariableName put: newCollection! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 01:37'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession	| oldCollection newCollection |	newCollection := self createRelationCollectionOn: aDataBaseSession ownedBy: anObject.	oldCollection := anObject instVarNamed: instanceVariableName.		newCollection addAll: oldCollection.	anObject instVarNamed: instanceVariableName put: newCollection! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 01:35'!createRelationCollectionOn: aDataBaseSession ownedBy: anObject	^ OneToManySet on: aDataBaseSession ownedBy: anObject! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 21:16'!embeded: anObject into: aRecord	! !!OneToManyMapping methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 23:34'!initializeFor: anInstanceVariableName into: aFieldName ofType: aClass	instanceVariableName := anInstanceVariableName.	fieldName := aFieldName.	relatedType := aClass ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!OneToManyMapping class	instanceVariableNames: ''!!OneToManyMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:40'!for: anInstanceVariableName into: aFieldName ofType: aClass	self assertValidFieldName: aFieldName.		^self new initializeFor: anInstanceVariableName into: aFieldName ofType: aClass! !!OneToManyMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:32'!withDefaultFieldNameFor: anInstanceVariableName ofType: aClass	^self for: anInstanceVariableName into: (self defaultFieldNameFor: anInstanceVariableName) ofType: aClass! !Set subclass: #OneToManySet	instanceVariableNames: 'session owner'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-PersistanceModel'!!OneToManySet methodsFor: 'adding' stamp: 'LREV 7/1/2018 14:19'!persistIfNotInSession: anObject	(self sessionContainsObject: anObject identifiedAs: (session idOf: anObject)) ifTrue: [ ^session ]. 	session persist: anObject.	^ session addRelated: anObject ownedBy: owner.! !!OneToManySet methodsFor: 'adding' stamp: 'LREV 7/1/2018 14:44'!sessionContainsObject: anObject identifiedAs: objectID	^ (objectID notNil) and: [ 		[anObject 	= (session objectIdentifiedAs: objectID ofType: anObject class) ] 		on: Error 		do: [ :error | ((error messageText) = ('Object identified as <1s> does not exist' expandMacrosWith: objectID printString) ) ifTrue: [^false] ]		]! !!OneToManySet methodsFor: 'adding' stamp: 'HernanWilkinson 11/1/2016 00:03'!addAllNotPersisting: aCollection 		^aCollection do: [ :anObjectToAdd | super add: anObjectToAdd ]! !!OneToManySet methodsFor: 'adding' stamp: 'LREV 7/1/2018 14:09'!add: anObject	self persistIfNotInSession: anObject.	super add: anObject.! !!OneToManySet methodsFor: 'initialization' stamp: 'HernanWilkinson 11/1/2016 00:11'!initializeOn: aDataBaseSession ownedBy: anOwner		session := aDataBaseSession.	owner := anOwner ! !!OneToManySet methodsFor: 'removing' stamp: 'HernanWilkinson 10/31/2016 21:35'!remove: anObject ifAbsent: anAbsentBlock	self shouldBeImplemented ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!OneToManySet class	instanceVariableNames: ''!!OneToManySet class methodsFor: 'instance creation' stamp: 'HernanWilkinson 11/1/2016 00:11'!on: aDataBaseSession ownedBy: anOwner		^self new initializeOn: aDataBaseSession ownedBy: anOwner ! !'From Pharo6.0 of 13 May 2016 [Latest update: #60528] on 2 July 2018 at 9:13:18.805344 am'!!String methodsFor: '*IS1-CustomerImport' stamp: 'HernanWilkinson 10/31/2016 23:57'!asPlural		^self last = $s 		ifTrue: [ self, 'es' ]		ifFalse: [ self, 's' ]! !'From Pharo6.0 of 13 May 2016 [Latest update: #60528] on 2 July 2018 at 9:13:18.806085 am'!!Object methodsFor: '*IS1-CustomerImport' stamp: 'HernanWilkinson 10/31/2016 19:27'!toDo: aString 	! !